#!/bin/bash
# Core expectations
#
#  Copyright (C) 2014 Mike Gewitz
#
#  This file is part of shspec.
#
#  shspec is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
##

[ -z $__INC_EXPECT_CORE ] || return
__INC_EXPECT_CORE=1

source util

# reserved for our uses
exec 99<>/dev/null


##
# Shorthand for bailing out on unrecognized clauses
_bail_clause()
{
  local -r type="$1"
  local -r clause="$2"

  _bail "unrecognized \`$type' clause: \`$2'"
}


##
# Asserts that at least the given argument shift count was provided
#
# The shift count is used to determine where shspec's arguments end and
# where the remainder clause begins; this ensures that shspec can continue
# to evolve in the future without BC breaks in properly designed expection
# handlers.
__chk-nshift()
{
  local -ri expect="$1"
  local -ri given="$2"

  test "$given" -ge "$expect" || _bail \
    "internal: expected shift of at least $expect, but given $given"
}


##
# Purely gramatical to make certain expectations flow more naturally when
# spoken
#
# For example, "to be silent".
_expect--be() { _proxy-to "$@"; }


_expect--succeed() { test "$1" -eq 0; }
_expect--fail()    { test "$1" -ne 0; }


_expect--output()
{
  local -ri nshift="$2"
  local -r stderr="$3"
  shift "$nshift"

  # output-specific clauses
  local -r cmp="$1"
  shift
  local -ar clause=("$@")

  local nl
  local intype
  {
    __expect--output-clause "${clause[@]}" | {
      IFS=\| read nl intype

      if [ "$intype" == stderr ]; then
        __chk-nshift 3 "$nshift"
        exec 99<"$stderr"
      fi

      # we will eventually be interested in this output
      # TODO: fast check first, diff if non-match
      diff <( echo $nl "$cmp" ) - <&99 &>/dev/null
    }
  } 99<&0

  aok "${PIPESTATUS[@]}"
}

__expect--output-clause()
{
  [ $# -gt 0 ] || return 0

  local nl=
  local input=

  if [ "$1 $2" == 'without newline' ]; then
    nl=-n
    shift 2
  fi

  if [ $# -gt 0 ]; then
    if [[ "$1 $2" =~ ^on\ std(err|out) ]]; then
      [ "$2" == stderr ] && input="$2"
    else
      _bail_clause output "$*"
    fi
  fi

  echo "$nl|$input"
}


_expect--match()
{
  shift "$2"
  local -r pat="$1"

  [[ "$(cat)" =~ $pat ]]
}

