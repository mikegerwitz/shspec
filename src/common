#!/bin/bash
# Common test case file
#
#  Copyright (C) 2014 LoVullo Associates, Inc.
#
#  This file is part of trello-sh.
#
#  trello-sh is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
##

declare -a __desc_stack=()
declare -i __desc_stackp=0

# current test csae
__desc_case=

# stderr file
__desc_errpath="$(mktemp)"

# most recent expect result and its exit code
__desc_result=
__desc_rexit=0

# most recent caller for assertions
__desc_caller=


__desc-push()
{
  __desc_stack[$__desc_stackp]="$*"
  ((__desc_stackp++))
}

__desc-pop()
{
  [ "$__desc_stackp" -gt 0 ] || return 1

  # notice that we unset before we decrease the pointer; this allows for a
  # single level of un-popping
  unset __desc_stack[$__desc_stackp]
  ((__desc_stackp--))
}

__desc-unpop()
{
  ((__desc_stackp++))
}

__desc-head()
{
  local headi=$((__desc_stackp - 1))
  echo "${__desc_stack[ $headi ]}"
}

__desc-headtype()
{
  local parts=( $(__desc-head) )
  echo "${parts[0]}"
}

__desc-assert-within()
{
  local in="$1"
  local chk="$2"
  local line="$3"
  local file="$4"
  local phrase="${5:-be contained within}"
  local head="$(__desc-headtype)"
  local printin="$(__desc-type-clean "$in")"

  [ "$head" == "$in" ] \
    || bail "\`$chk' must $phrase \`$printin'; found \`$head' at $file:$line"
}

__desc-type-clean()
{
  # a colon prefix is semantic; strip for display
  echo "${1#:}"
}

__desc-assert-follow()
{
  __desc-assert-within "$@" follow
}


begin-case()
{
  __desc_case="$1"
}

tests()
{
  source ../src/"$1"
}

describe()
{
  __desc-push "describe $(caller) $@"
}

it()
{
  __desc-push "it $(caller) $@"
}

end()
{
  local head="$(__desc-headtype)"
  local cleanhead="$(__desc-type-clean "$head")"

  # some statements are implicitly terminated; explicitly doing so is
  # indicitive of a syntax issue
  [ "${head:0:1}" != : ] \
    || bail "unexpected \`end': still processing \`$cleanhead'" $(caller)

  __desc-pop || bail "unmatched \`end'"
}

end-case()
{
  local tcase="$__desc_case"
  __desc_case=

  # nothing to do if our stack is clean
  [ "$__desc_stackp" -gt 0 ] || return 0

  # output an error message for each item in the stack
  while ((__desc_stackp--)); do
    read type line file __ <<< "$(__desc-head)"
    echo "error: $tcase: unterminated \`$type' at $file:$line"
  done

  exit 1
}

bail()
{
  local msg="$1"
  local line="$2"
  local file="$3"

  echo -n "error: $1" >&2
  [ $# -gt 1 ] && echo -n " at $file:$line" >&2

  echo
  exit 1
}


expect()
{
  __desc-assert-within it expect $(caller)
  __desc_result="$($@ 2>"$__desc_errpath")"
  __desc_rexit=$?
  __desc-push ":expect $(caller) $@"
}

to()
{
  __desc_caller=${__desc_caller:-$(caller)}

  [ $# -gt 0 ] || bail "missing assertion string for \`to'" $__desc_caller

  local type="$1"
  shift

  __desc-assert-follow :expect to $(caller)
  __desc-pop

  local assert="_desca-$type"
  [ "$( type -t "$assert" )" == function ] \
    || bail "unknown \`to' assertion: \`$type'" $__desc_caller

  # invoke partially-applied assertion with remaining arguments
  $assert "$@" || fail
  __desc_caller=
}

and()
{
  __desc_caller="$(caller)"
  __desc-unpop
  "$@"
}


#
# Assertions
#
_desca-succeed()
{
  __desca-exit -eq 0
}

_desca-fail()
{
  __desca-exit -ne 0
}

_desca-exit()
{
  __desca--argsep with 2 __desca-exit -eq
}


__desca-exit()
{
  __desca--argn 2 "$#"
  [ "$__desc_rexit" "$@" ]
}

_desca-output()
{
  local cmp="$1"

  diff="$( diff <( echo "$__desc_result" ) <( echo "$cmp" ) )" \
    && return 0

  echo "$diff" >&2
  return 1
}

__desca--argsep()
{
  local delim="$1"
  local cmdlen="$2"
  local partial=
  shift 2

  # bash doesn't support multi-dimensional arrays, so here's to awkward command
  # reconstruction with argument counts
  while ((cmdlen--)); do
    partial="$partial $1"
    shift
  done

  local next="$1"
  shift

  [ "$next" == "$delim" ] \
    || bail "expected \`$delim' but found \`$next'" $__desc_caller

  $partial "$@"
}

__desca--argn()
{
  [ $2 -eq "$1" ] || bail "invalid number of arguments" $__desc_caller
}

